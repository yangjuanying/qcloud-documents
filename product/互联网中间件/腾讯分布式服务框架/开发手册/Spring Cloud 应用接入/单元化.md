## 操作场景
TSF 支持使用单元化功能以达到让不同的业务流量根据一定的单元化规则分发到指定的单元里，不同单元之间通过微服务网关实现跨单元调用，当某个单元内的服务器实例出现问题时也不会影响到其他单元业务的使用，使得业务受影响粒度达到最小，同时单元化也为业务容灾高可用提供了强有力的保障。

## 前提条件
开始实践单元化功能前，请确保已完成了 [SDK 下载](https://cloud.tencent.com/document/product/649/20231)，同时请确保 SDK 版本高于**1.28**。

## 操作步骤
>?先暴露provider服务接口，然后将单元化规则配置在调用方consumer工程或网关工程里。

### 配置consumer工程
**1. 向consumer工程中添加依赖。**
在 `pom.xml` 中添加以下代码：
```xml
<dependency>
    <groupId>com.tencent.tsf</groupId>
    <artifactId>spring-cloud-tsf-starter</artifactId>
    <version><!-- 调整为 SDK 最新版本号 --></version> 
</dependency>
```
**2. 向 Application 类中添加注解 `@EnableTsf`和`@ComponentScan`：**
```java
// 下面省略了无关的代码
@SpringBootApplication
@EnableTsf
@EnableFeignClients // 使用Feign微服务调用时请启用
@ComponentScan(basePackages="com.tsf.demo.consumer.*") // 需要扫描单元化@TsfUnitRule注解所在的包
public class ConsumerApplication {
    public static void main(String[] args) throws InterruptedException {
        SpringApplication.run(ConsumerApplication.class, args);
    }
}
```
**3. 使用 `@TsfUnitRule`配置单元化规则。**
TSF 容错兼容 feign 的容错功能，如果需要使用 feign 的如下降级功能，则需要关闭 Hystrix 开关。
```
@FeignClient(name = "provider-demo")
public interface ProviderDemoService {
    
    @TsfUnitRule(ruleGenerator = "com.tsf.demo.consumer.util.UserIdGenerator")
    @RequestMapping(value = "/echo/unit/{str}", method = RequestMethod.GET)
    String echoUnit(@PathVariable("str") String str);
}
```
**4. 在代码中编写单元化规则。**
其中UserIdGenerator就是步骤3中`@TsfUnitRule`的ruleGenerator属性指定的类
```java
// 下面省略了无关的代码
public class UserIdGenerator implements TsfUnitRuleGenerator {

    /** 
     * 
     * @see com.tencent.tsf.unit.util.TsfUnitRuleGenerator#generateRule(java.lang.reflect.Method, java.lang.Object[])
     */
    @Override
    public Map<String, String> generateRule(Method method, Object[] args) {
        String userId = (String)args[0];
        Map<String, String> ruleMap = new HashMap<>();
        // 添加单元化规则的tag key
        ruleMap.put("userId", userId);
        return ruleMap;
    }

}
```
可以看到，TSF 的容错使用起来非常方便，您只需在需要保护的方法上增加一个注解即可（需要该 Bean 被 Spring 所管理）。

#### 容错策略说明
failfast、failover 和 forking 容错策略是可选择的配置：

|容错策略|含义|支持配置|
|----|----|-----|
|failfast|直接失败，对于没有幂等性的下游服务推荐 failfast|无|
|failover|请求错了之后会重试|重试次数 maxAttempts|
|forking|同时发送多个请求，需要用户配置并行度，例如同时发出两个请求，哪个先返回，就把这个结果返回回去。如果第一个请求是异常，则会等另一个请求，如果全部都异常，则返回异常。|并行度 parallelism|

**三种容错策略均支持 fallback 方法，要求入参类型和返回值类型与原方法相同。您可以选择是否添加某一策略**。

除了如上所述的基本功能外，TSF 还提供了选择容错异常的能力：
```java
// 下面省略了无关的代码
@TsfFaultTolerance(strategy = TsfFaultToleranceStragety.FAIL_OVER, parallelism = 2, ignoreExceptions = {FeignException.class}, raisedExceptions = {RuntimeException.class, InterruptedException.class}, fallbackMethod = "doWorkFallback")
public void doWork() throws InterruptedException {
    String response = providerDemoService.echo("1234");
    LOG.info("consumer-demo auto test, response: [" + response + "]");
}

public void doWorkFallback() {
    System.out.println("fallback");
}
```
- 用户如果设置了 ignoreExceptions，且当前异常是其中一个的子类的话，则不执行容错逻辑。
- 如果用户没有设置 ignoreExceptions，或当前异常不是 ignoreExceptions 的子类且满足如下条件则执行容错逻辑：
 - 用户未设置 raisedExceptions，则执行容错逻辑。
 - 用户设定了 raisedExceptions，且当前异常为用户设置的 raisedExceptions 其中一个的子类，则执行容错逻辑。


